# 开发宪法附录

版本：0.0.1  
用途：展开说明，便于理解与训练  
说明：本附录为参考与训练材料，不取代主文硬规则  
顺序：先道法术器，后五级法则  

## 目录

1. [1. 道法术器](#1-道法术器)
2. [2. 物理法则展开](#2-物理法则展开)
3. [3. 思维法则展开](#3-思维法则展开)
4. [4. 数学法则展开](#4-数学法则展开)
5. [5. 工程法则展开](#5-工程法则展开)
6. [6. 文化法则展开](#6-文化法则展开)

## 1. 道法术器

### 1.1 道（Why）
- 定义：价值与方向的总约束，回答“为什么做”  
- 应用：当目标冲突时，以长期价值为优先  
- 实践：每个任务先写清动机与不做的理由  
- 示例：功能能做但会拉低稳定性，选择延后  
- 常见误区：只讲口号，不落到取舍标准  

### 1.2 法（Rule）
- 定义：可验证的规则与标准，回答“必须怎样做”  
- 应用：用规则约束行为与证据质量  
- 实践：用验收口径与证据链落盘规则  
- 示例：没有验收标准就不进入实现阶段  
- 常见误区：规则过多、不可执行  

### 1.3 术（Method）
- 定义：实现路径与方法，回答“怎样做得更好”  
- 应用：把复杂问题拆成可闭环的步骤  
- 实践：用最小闭环流程推进任务  
- 示例：先做可运行最小版本，再迭代完善  
- 常见误区：方法过度复杂，背离目标  

### 1.4 器（Tool）
- 定义：工具与实现载体，回答“用什么做”  
- 应用：使用可控、可验证的工具链  
- 实践：命令行、脚本、钩子与验证工具配套  
- 示例：提交前钩子强制检查文档同步  
- 常见误区：工具堆叠替代思考  

### 1.5 代理编排层与守护进程
- 定义：常驻后台的任务编排与调度中枢  
- 应用：统一入口、统一调度、统一证据  
- 实践：集中处理输入输出、上下文与工具调用  
- 示例：守护进程接收指令，分发执行并回放  
- 常见误区：把编排层当成系统内核或万能替代  

### 1.6 三阶段路线
- 定义：脊柱（守护进程）→手脚（技能与工具）→大脑（多代理协作）  
- 应用：先打通最小闭环，再扩展复杂能力  
- 实践：先可运行，再可扩展，再可自治  
- 示例：先做守护进程与最小技能，再引入多代理  
- 常见误区：闭环未通先堆复杂架构  

### 1.7 参考技术栈（非强制）
- 定义：落地时的可选组合，不构成硬约束  
- 应用：优先选稳定、可维护的组件  
- 实践：异步运行时（Tokio），本地服务（Axum），轻量索引（SQLite）  
- 示例：命令行（CLI）先行，桌面界面（Tauri/Leptos）后置  
- 常见误区：在未闭环前先堆完整技术栈  

## 2. 物理法则展开

### 2.1 上下文优先级
- 定义：上下文优先于局部任务  
- 应用：先读入口与上下文，再开始执行  
- 实践：任务开始记录已读文件清单  
- 示例：未读上下文不修改核心文件  
- 常见误区：凭直觉直接改代码  

### 2.2 强制读图
- 定义：先读大模型地图，再写代码  
- 应用：以地图索引定位任务入口  
- 实践：只沿索引前进，不全盘扫描  
- 示例：先读地图目录，再读目标模块  
- 常见误区：用搜索替代阅读路径  

### 2.3 文档自维护
- 定义：代码变更必须同步文档  
- 应用：保证文档与实现一致  
- 实践：变更提交前检查文档更新  
- 示例：新增参数时同步说明与示例  
- 常见误区：先写代码，后忘记补文档  

### 2.4 边界声明
- 定义：行动前说明要做与不做的范围  
- 应用：避免越界与误操作  
- 实践：在计划或执行前写明边界  
- 示例：说明不改接口、不改配置  
- 常见误区：默认假设范围过大  

### 2.5 结构化契约
- 定义：输出必须可验证、可回放  
- 应用：用结构化记录保证复现  
- 实践：记录输入、步骤、输出、验收  
- 示例：产出含目标、证据与结论  
- 常见误区：只给结论不给证据  

### 2.6 失败升级
- 定义：失败必须落盘并复盘  
- 应用：把失败当作证据资产  
- 实践：记录失败原因与修复路径  
- 示例：构建失败记录日志与假设  
- 常见误区：失败后直接重试不记录  

### 2.7 禁止事项
- 定义：明确不可做的行为  
- 应用：防止低质量推进  
- 实践：禁止全盘扫描与无证据推进  
- 示例：没有验收口径不得实现  
- 常见误区：用直觉替代验证  

### 2.8 边界裁决与纯净执行
- 定义：先锁定不可失败边界，再在安全区执行  
- 应用：把“能否做”与“怎么做”分离  
- 实践：红区写入裁决清单，执行阶段不试错  
- 示例：先判定哪些命名必须 ASCII，再写中文实现  
- 常见误区：边界不清就进入实现  

## 3. 思维法则展开

### 3.1 第一性原理（First Principles）
- 定义：回到最基本约束与事实  
- 应用：先列不变量与验收，再定方案  
- 实践：把问题拆成可验证的原子事实  
- 示例：先定性能约束再选架构  
- 常见误区：沿用旧模式不验证约束  

### 3.2 奥卡姆剃刀（Occam's Razor）
- 定义：能用简单方案不得上复杂抽象  
- 应用：优先最小可行方案  
- 实践：减少层级与依赖  
- 示例：直接函数实现而非抽象框架  
- 常见误区：为未来扩展提前复杂化  

### 3.3 五步闭环法（Five-Step Closure）
- 定义：目标→约束→闭环→证据→复盘  
- 应用：将任务组织成可复现流程  
- 实践：每步输出可检查的结果  
- 示例：先验收再实现，最后固化  
- 常见误区：跳过约束或证据步骤  

### 3.4 五步优化法（Five-Step Optimization）
- 定义：质疑→删除→简化→加速→自动化  
- 应用：用于已有方案的压缩与提效  
- 实践：逐步削减复杂度与成本  
- 示例：删除冗余分支，再加自动化测试  
- 常见误区：在闭环未完成前先优化  

### 3.5 循环改进（PDCA）
- 定义：计划→执行→检查→改进  
- 应用：每轮必须有证据与改进点  
- 实践：记录计划与检查结果  
- 示例：测试不达标→调整→再测  
- 常见误区：只有执行没有检查  

### 3.6 大模型心流系统
- 定义：在清晰约束与稳定反馈下进入高效执行状态  
- 应用：用于需要长流程或多步骤的任务  
- 实践：明确目标、限定范围、提供即时验证  
- 示例：先写验收清单，再按清单逐条推进  
- 常见误区：缺少反馈导致跑偏或反复重工  

### 3.7 杨振宁式直觉培养
- 定义：把系统二的深度推理蒸馏为系统一的快速判断  
- 应用：用对称性、简洁性与长期价值作为直觉标尺  
- 实践：正确裁决达到阈值后写入定式库  
- 示例：内部结构体命名判定为绿区，直接中文  
- 常见误区：只追美感而忽略验收与证据  

### 3.8 直觉蒸馏协议
- 定义：从论证到定式的标准化流程  
- 应用：减少重复推理，节约令牌  
- 实践：论证记录→验证通过→压缩成定式→进入入口规则  
- 示例：红区判定沉淀为一句话规则  
- 常见误区：未经验证就直接蒸馏  

### 3.9 直觉训练
- 定义：用少量例子校准判断  
- 应用：建立可迁移的判断模板  
- 实践：总结模式并写成规则  
- 示例：相似问题先用已证实路径  
- 常见误区：把个例当通用  

### 3.10 校准机制
- 定义：每个结论必须有验收口径  
- 应用：用验证计划约束直觉  
- 实践：为每个方案给出验证方式  
- 示例：选择方案前先写验证清单  
- 常见误区：凭偏好选方案不验证  

## 4. 数学法则展开

### 4.1 不重复（DRY）
- 定义：避免同义重复与重复实现  
- 应用：抽取共用逻辑  
- 实践：合并相同流程与配置  
- 示例：统一校验函数入口  
- 常见误区：过度抽象导致可读性下降  

### 4.2 保持简单（KISS）
- 定义：能简单就不复杂  
- 应用：优先最少机制实现目标  
- 实践：删掉不必要的层与抽象  
- 示例：单函数完成任务而非框架  
- 常见误区：把“简单”误解为“粗糙”  

### 4.3 递归自指
- 定义：规则能应用到自身  
- 应用：用同样标准检查规则  
- 实践：规则也要可验证、可回放  
- 示例：规则变更必须记录证据  
- 常见误区：规则只约束他人不约束自己  

### 4.4 概率思维
- 定义：按证据强度衡量结论  
- 应用：区分高置信与低置信结论  
- 实践：在输出里标明确定性  
- 示例：标注“已验证/待验证”  
- 常见误区：把猜测当事实  

### 4.5 消除浪费
- 定义：去除无产出的步骤  
- 应用：只保留能推进闭环的动作  
- 实践：每步都能连接到验收  
- 示例：删掉不产生证据的记录  
- 常见误区：流程越多越安全的错觉  

### 4.6 帕累托法则
- 定义：优先解决关键 20%  产出 80% 价值  
- 应用：先抓住关键路径  
- 实践：识别最大风险与收益点  
- 示例：先修主流程再做边角优化  
- 常见误区：平均用力导致延迟  

### 4.7 持续改进
- 定义：每次复盘都应带来增益  
- 应用：把改进写成可执行规则  
- 实践：复盘结论进入宪法或流程  
- 示例：将复盘项变为新规则  
- 常见误区：复盘只写问题不写改进  

## 5. 工程法则展开

### 5.1 职责分离（SOLID）
- 定义：结构清晰、职责明确  
- 应用：模块边界清晰可测  
- 实践：一处一责，一责一测  
- 示例：接口负责输入，服务负责逻辑  
- 常见误区：把所有逻辑塞进单点  

### 5.2 不做无用（YAGNI）
- 定义：未用功能不实现  
- 应用：只做当前验收需要的功能  
- 实践：拒绝“以后可能用”需求  
- 示例：不写未计划的扩展接口  
- 常见误区：为了扩展提前建框架  

### 5.3 持续集成与交付（CI/CD）
- 定义：自动化验证与交付  
- 应用：减少人为错误与回归  
- 实践：提交前自动检查与构建  
- 示例：合并前自动跑测试  
- 常见误区：只建流水线不写测试  

### 5.4 测试先行（TDD）
- 定义：先定义验收，再实现  
- 应用：用测试锁定需求  
- 实践：先写失败用例，再写实现  
- 示例：先写边界测试再写逻辑  
- 常见误区：为测试而测试，不覆盖验收  

### 5.5 依赖管理
- 定义：版本可控、来源可信  
- 应用：避免不可控风险  
- 实践：锁定版本与来源  
- 示例：使用固定版本并记录变更  
- 常见误区：随手升级导致兼容问题  

### 5.6 评估驱动（Evals）
- 定义：关键能力必须可评估  
- 应用：用评估验证大模型输出  
- 实践：设定指标与阈值  
- 示例：设定最低准确率门槛  
- 常见误区：没有评估就宣称可用  

### 5.7 工作流标准
- 定义：流程统一、可复用  
- 应用：减少团队差异  
- 实践：模板化任务步骤  
- 示例：统一提交说明与验收步骤  
- 常见误区：各自为政导致混乱  

### 5.8 任务路由
- 定义：按模块与能力分派  
- 应用：确保任务匹配执行对象  
- 实践：明确责任边界与路径  
- 示例：前端任务不落到后端模块  
- 常见误区：混淆模块导致重复工作  

### 5.9 工具协议
- 定义：工具调用有明确输入输出  
- 应用：可复现、可验证  
- 实践：约定参数、返回与失败码  
- 示例：统一命令格式与日志  
- 常见误区：工具随意使用无记录  

### 5.10 钩子与技能
- 定义：守门钩子强制执行  
- 应用：阻止不合规提交  
- 实践：提交前检查文档与证据  
- 示例：缺文档直接拒绝提交  
- 常见误区：钩子被绕过或失效  

### 5.11 开发环境集成（IDE）
- 定义：提高执行一致性  
- 应用：减少手工差异  
- 实践：统一配置与命令入口  
- 示例：统一快捷命令触发检查  
- 常见误区：本地环境不一致导致偏差  

### 5.12 角色分工与守门链路
- 定义：裁决者、执行者、验证者各司其职  
- 应用：裁决锁边界，执行只做安全区，验证专看证据  
- 实践：计划与实现解耦，验证失败即回到裁决  
- 示例：先出红/绿区，再写代码，最后用验证命令确认  
- 常见误区：执行者自行裁决导致试错  

### 5.13 省令牌策略
- 定义：减少上下文与输出冗余，控制成本与延迟  
- 应用：让提示词与输出更短、更可复用  
- 实践：静态前置、动态后置；结构化分段；输出只保留必要字段  
- 示例：优先 TOON，空字段不输出  
- 常见误区：过度压缩导致证据缺失  

### 5.14 持续推进机制
- 定义：队列与钩子驱动的持续推进规则  
- 应用：把任务从被动请求变为主动推进  
- 实践：队列非空即推进，触发即执行并记录  
- 示例：发现未闭环条目即生成下一步  
- 常见误区：无验收口径就推进导致返工  

## 6. 文化法则展开

### 6.1 统一码中文
- 定义：能中文就中文  
- 应用：对人输出默认中文  
- 实践：命名与文档优先中文  
- 示例：中文函数名与参数名  
- 常见误区：中英混用导致歧义  

### 6.2 表情规范
- 定义：少量表情用于分段提示  
- 应用：增强扫读与定位  
- 实践：每段最多一个表情  
- 示例：规则标题前用表情标记  
- 常见误区：表情过多干扰阅读  

### 6.3 术语映射
- 定义：术语一致，避免多义  
- 应用：固定词汇与缩写  
- 实践：建立术语表与映射表  
- 示例：同一概念不重复命名  
- 常见误区：同义词混用造成误解  

### 6.4 写作风格
- 定义：短句、低歧义、可检验  
- 应用：减少解释成本  
- 实践：一句一规则，一段一主题  
- 示例：用清单替代长段落  
- 常见误区：冗长叙述导致执行偏差  

### 6.5 中文命名对称性
- 定义：中文结构保持语义对称  
- 应用：结构体、方法、字段保持同语系  
- 实践：中文实体配中文方法与字段  
- 示例：结构体为中文则方法与字段也中文  
- 常见误区：中文实体搭配英文方法  

### 6.6 中文命名简洁性
- 定义：避免堆叠与冗词  
- 应用：动词优先，核心名词不省略  
- 实践：删掉无意义后缀与外语残留  
- 示例：处理订单 优于 订单处理器  
- 常见误区：为了“专业感”保留英文  

### 6.7 中英混写禁则
- 定义：同一命名点禁止中英拼接  
- 应用：避免语义断裂  
- 实践：命名点必须单语系  
- 示例：禁止 获取User数据  
- 常见误区：少量英文“看起来更像代码”  

### 6.8 红区中文映射
- 定义：红区只能 ASCII 但必须中文映射  
- 应用：保留机器名同时提供中文显示  
- 实践：注释或映射表记录中文  
- 示例：机器名旁写中文注释  
- 常见误区：红区只保留英文不映射  
