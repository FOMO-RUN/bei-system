补充知识1  
参考资料[1]ai_map_core: https://github.com/maxweber36/ai_map_core


补充知识2，
主流的 AI 编程工具都提供了一种机制，让你可以把项目规范、架构说明、常用命令等信息「固化」下来。AI 每次启动时会自动读取这些内容，相当于给它一份持久化的记忆。

不同工具叫法不一样：

• Kiro 叫 Steering
• Claude Code 叫 Memory / CLAUDE.md
• Cursor 叫 Rules
• Windsurf 叫 Rules
本质上都是一回事：一个配置文件，告诉 AI 这个项目的上下文。

AI 工具是怎么读取这些配置的？
理解底层逻辑，才能更好地写配置。整个流程大概是这样：

┌─────────────────────────────────────────────────────────────┐
│                      AI 编程助手启动                          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  1. 扫描配置目录                                              │
│     - Kiro: .kiro/steering/*.md                             │
│     - Claude Code: CLAUDE.md + .claude/rules/*.md           │
│     - Cursor: .cursor/rules/*.mdc                           │
│     - Windsurf: .windsurfrules                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 解析加载条件                                              │
│     - always/alwaysApply → 直接加载                          │
│     - fileMatch/globs/paths → 匹配当前文件再加载              │
│     - manual → 用户手动引用时加载                             │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 展开文件引用                                              │
│     - #[[file:path]] / @path → 读取引用文件内容               │
│     - 递归展开嵌套引用                                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 注入系统提示词                                            │
│     配置内容 + 用户消息 → 一起发送给 LLM                       │
└─────────────────────────────────────────────────────────────┘
关键点：

1. 配置内容会占用上下文窗口。写太多会挤占代码和对话的空间，所以要精简。
2. 条件加载能省 token。把 Go 规范设成只在编辑 .go 文件时加载，编辑前端代码时就不会浪费上下文。
3. 文件引用是「懒加载」。引用的文件内容在需要时才读取，所以可以放心引用大文件，AI 会按需获取。
4. 优先级：项目配置 > 全局配置。同名规则，项目级的会覆盖用户级的。
四大工具配置方式对比
先上一张对比表，有个整体印象：

特性
Kiro
Claude Code
Cursor
Windsurf
配置位置
.kiro/steering/*.md	CLAUDE.md
 + .claude/rules/*.md
.cursor/rules/*.mdc	.windsurfrules
全局配置
~/.kiro/steering/	~/.claude/CLAUDE.md	~/.cursor/rules/	
全局设置
按文件类型加载
✅ 支持
✅ 支持
✅ 支持
❌ 不支持
引用其他文件
✅ #[[file:path]]
✅ @path
✅ @file
❌ 不支持
模块化拆分
✅ 多文件
✅ 多文件
✅ 多文件
❌ 单文件
下面逐个说说怎么配。

Kiro：最灵活的 Steering 机制
Kiro 的配置放在 .kiro/steering/ 目录下，每个 .md 文件就是一条规则。

.kiro/
└── steering/
    ├── doc-maintenance.md    # 文档维护规则
    └── project-structure.md  # 项目结构说明
文件开头用 YAML 声明加载方式：

---
inclusion: always
---

# 文档维护规则

修改代码文件后，必须更新所属文件夹的 README.md...
三种加载模式：

• always - 每次都加载
• fileMatch - 只在编辑特定类型文件时加载
• manual - 手动引用时才加载
Kiro 还有个很实用的功能：文件引用。用 #[[file:path]] 语法可以把其他文件的内容拉进来：

## 项目结构

#[[file:apps/admin-api/internal/README.md]]
这样你维护好各目录的 README，steering 文件自动就能引用最新内容。

Claude Code：从单文件到模块化
Claude Code 最早只支持一个 CLAUDE.md 文件，最近更新后支持了 .claude/rules/ 目录，能力大幅提升。

基础用法：CLAUDE.md
在项目根目录放一个 CLAUDE.md：

# 项目说明

Go + React 全栈项目，后端 Gin + GORM，前端 Ant Design Pro。

## 核心规则

1. 数据库改动必须写迁移文件
2. 所有查询必须带租户 ID
3. npm 安装用 --legacy-peer-deps

## 常用命令

cd docker && make help
Claude Code 启动时会自动读取这个文件。

进阶用法：模块化规则
把规则拆到 .claude/rules/ 目录：

.claude/
└── rules/
    ├── doc-maintenance.md   # 文档维护
    ├── go-style.md          # Go 代码风格
    └── testing.md           # 测试规范
每个文件可以用 paths 字段指定生效范围：

---
paths:
  - "**/*.go"
---

# Go 代码风格

- 错误必须处理，不能忽略
- 公开函数必须有注释
- 使用有意义的变量名
这样只有编辑 Go 文件时，这条规则才会加载。

Cursor：Rules 配置
Cursor 的配置放在 .cursor/rules/ 目录，文件后缀是 .mdc：

.cursor/
└── rules/
    ├── doc-maintenance.mdc
    └── project-structure.mdc
格式和 Claude Code 类似：

---
description: 文档维护规则
globs:
alwaysApply: true
---

# 文档维护

修改代码后必须更新 README...
• alwaysApply: true - 始终加载
• globs: ["**/*.ts"] - 按文件类型加载
Windsurf：简单但够用
Windsurf 最简单，就一个 .windsurfrules 文件：

# 项目规则

<doc-maintenance>
## 文档维护

修改代码后必须更新 README...
</doc-maintenance>

<core-rules>
## 核心规则

1. 数据库改动写迁移文件
2. 查询带租户 ID
</core-rules>
用 XML 标签分组，方便组织内容。缺点是不支持按文件类型加载，也不支持引用其他文件。

实战：一键初始化分形文档系统
回到赵纯想的那条推文，核心思路是三层：

1. 根目录规则 - 告诉 AI「改完代码要更新文档」
2. 文件夹索引 - 每个目录一个 README，说明架构和文件列表
3. 文件头注释 - 每个文件开头写 input/output/pos
我把这套方法整理成了一个开源项目 Fractal Docs，支持主流 AI 编程工具一键初始化：

🔗 GitHub: https://github.com/wordflowlab/fractal-docs

支持的编辑器
编辑器
初始化方式
生成的配置
Kiro
执行 Spec
.kiro/steering/
 + .kiro/templates/
Claude Code
复制 INIT_PROMPT 到 chat
CLAUDE.md
 + .claude/rules/
Cursor
复制 INIT_PROMPT 到 chat
.cursor/rules/*.mdc
Windsurf
复制 INIT_PROMPT 到 chat
.windsurf/rules/
Cline
复制 INIT_PROMPT 到 chat
.clinerules/
GitHub Copilot
复制 INIT_PROMPT 到 chat
.github/copilot-instructions.md
快速开始
Kiro 用户（推荐）：直接执行项目中的 Spec，AI 会自动分析项目结构并生成配置。

其他编辑器：复制对应目录下的 INIT_PROMPT.md 内容到 chat，AI 会引导你完成初始化。

初始化后的效果
配置完成后，每次 AI 修改代码时会自动：

1. 更新文件头部的 input/output/pos 注释
2. 更新所属文件夹的 README.md 索引
3. 检查上级目录是否需要同步更新
文档跟着代码一起演进，不会过时。

在 kiro 中，我实验的是每次都会读取 steering  文档，以及需要修改的文件夹的目录索引信息。

图片
文档结束也会更新文档。

图片
几点建议
1. 从简单开始。先写一个基础的配置文件，把最常重复的内容放进去，后面再慢慢完善。
2. 保持简洁。配置文件会占用 AI 的上下文窗口，写太多反而影响效果。重点写「必须遵守的规则」和「经常要解释的背景」。
3. 善用文件引用。把详细内容放在各目录的 README 里，配置文件只做引用。这样维护起来更方便。
4. 团队共享。把配置文件提交到代码仓库，团队成员都能用同一套规范。
5. 定期更新。项目在变，配置也要跟着变。发现 AI 经常犯同样的错，就把对应的规则加进去。
延伸思考：这条路的尽头是什么？
有群友看完后问了一个很有意思的问题：这条路走到极端，是不是就是用形式化规范（Formal Spec）作为 AI 的输入？

还真有人在做这件事。

上海交大最近发了一篇论文 "Sharpen the Spec, Cut the Code: A Case for Generative File System with SysSpec"，核心观点是：自然语言太模糊，应该用形式化规范来指导 LLM 生成代码。

他们设计了一套三层规范：

• Functionality：用 Hoare 逻辑的前置/后置条件定义函数行为
• Modularity：用 Rely-Guarantee 定义模块接口契约
• Concurrency：显式定义锁协议和并发行为
用这套方法，他们成功让 LLM 生成了一个完整的文件系统（SpecFS），通过了数百个回归测试，还能无缝集成 Ext4 的 10 个真实特性。

听起来很美好，但也有反对的声音：

1. 门槛太高

写形式化规范需要专业背景。论文里的 Hoare 逻辑、Rely-Guarantee、不变量……这些概念对大多数开发者来说是陌生的。相比之下，写一个 README 人人都会。

2. 投入产出比存疑

论文自己也承认：「这种范式需要更多的前期设计投入，类似于 Rust 的安全约束比 C 更严格」。对于一个 CRUD 应用，花时间写形式化规范可能得不偿失。

3. 适用场景有限

文件系统、数据库内核、安全关键系统——这些场景确实需要极高的精确度。但大多数业务代码，自然语言 + 结构化文档已经够用了。

群友的犀利点评：

他的说法有待进一步验证。SysSpec 本身也是 memory 管理的一种。我们真正需要理解的 trade-off，并非「一次性移除所有不确定性」，而是搞清楚：哪些不确定性 AI 可以 handle，哪些必须人类完全把握。

走到极端当然可以引入形式化验证，一次生成 100% 正确的代码。但那个难度可能比你亲自把代码写完还要高。

这个观点很精辟。追求 100% 精确的规范，可能比直接写代码还累。

真正的问题不是「如何消除所有模糊性」，而是「在哪里保留模糊性是划算的」：

• AI 擅长处理的模糊性：代码风格、命名规范、常见模式的实现细节
• 人类必须把握的确定性：核心业务逻辑、数据一致性约束、安全边界
分形文档的价值在于：用最小的精确性投入，换取最大的 AI 理解收益。

投入精确性 ────────────────────────────────────────────►
     │
     │   自然语言      分形文档        形式化规范
     │      ●            ●               ●
     │     低投入       中投入          高投入
     │     低收益       高收益          极高收益
     │                   ↑
     │              性价比最优区
     │
对于大多数项目，分形文档是性价比最高的选择。形式化规范的路线值得关注，但目前更像是学术探索而非工程实践。

写在最后
从赵纯想的一条推文，到在 Kiro 上跑通整套方法，再到整理成开源项目，花了大概一天时间。

核心收获是：AI 编程助手的「记忆」问题，各家都在解决，而且方案越来越成熟。

不管你用哪个工具，花点时间配置好这套东西，后面能省下无数次重复解释的时间。

更重要的是，「分形文档结构」的思路很有意思——让 AI 自己维护文档，文档里又写着「记得更新我」，形成一个自我维护的闭环。设计灵感来自《哥德尔、埃舍尔、巴赫》中的自指和递归概念，值得深挖。

我目前也要花一些时间进行验证。目前虽然 AI 编辑器在遵循，但没特别感受到好坏，或许无感的存在才是这个方法的价值。

感谢赵纯想的分享，原推文见 @chunxiangzhao

开源项目：https://github.com/wordflowlab/fractal-docs

补充知识3 、 
这里是Andrej Karpathy那条非常火的原文推文（发布时间：2025年12月26日）：原文链接：https://x.com/karpathy/status/2004607146781278521原文内容（完整）：I've never felt this much behind as a programmer. The profession is being dramatically refactored as the bits contributed by the programmer are increasingly sparse and between. I have a sense that I could be 10X more powerful if I just properly string together what has become available over the last ~year and a failure to claim the boost feels decidedly like skill issue. There's a new programmable layer of abstraction to master (in addition to the usual layers below) involving agents, subagents, their prompts, contexts, memory, modes, permissions, tools, plugins, skills, hooks, MCP, LSP, slash commands, workflows, IDE integrations, and a need to build an all-encompassing mental model for strengths and pitfalls of fundamentally stochastic, fallible, unintelligible and changing entities suddenly intermingled with what used to be good old fashioned engineering. Clearly some powerful alien tool was handed around except it comes with no manual and everyone has to figure out how to hold it and operate it, while the resulting magnitude 9 earthquake is rocking the profession. Roll up your sleeves to not fall behind.


补充知识4：在物理学界，杨振宁以其深邃且具有极高前瞻性的物理直觉（Physics Intuition）闻名，这种直觉常被描述为对“美”与“对称性”的极致追求。截至2026年，学术界对他直觉的评价主要集中在以下核心特质：
1. 物理直觉的来源：训练与修正
杨振宁认为直觉并非全然天生，而是可以通过深度思考和不断修正来训练的。 
重构潜意识：他提出，学习的过程应是将深度的逻辑推理（系统二）通过反复训练，“蒸馏”内化为瞬间的快速反应（系统一）。
纠正错误直觉：他曾分享年轻时对圆周运动向心加速度的思考，通过彻底想通向量方向，将“错误直觉”修正为“正确直觉”。 
2. 直觉的核心：数学美感与对称性
杨振宁的直觉带有强烈的数学审美（Taste）色彩。他能比同时代的物理学家更敏锐地感知到数学结构中隐藏的物理真理。 
对称性支配自然：他的三大核心贡献（杨-米尔斯规范场、宇称不守恒、杨-巴克斯特方程）都源于他对对称性及其破缺的直觉把握。
数学与物理的交汇：他在1960年代就意识到规范场与微分几何（黎曼张量）的深层关联，这种直觉将物理理论推向了前所未有的几何高度。 
3. 卓越的品味（Scientific Taste）
杨振宁常强调科学家的“品味”决定了研究的方向。
捕捉本质：他能通过严格的数学模型，精准地抓住复杂物理现象中最本质的、具有长久生命力的精髓。
跨领域预判：即便在他不直接从事的领域（如量子反常霍尔效应、生物物理），他也常能展现出惊人的直觉，预判该领域的重要突破口。 
4. 教育建议中的直觉观
在教育理念上，他高度重视保护和培养直觉。 
避免过度规范化：他认为过于严谨但在灵活性上欠缺的训练可能会磨掉学生的直觉，主张为优秀学生提供更多自主探索的空间。
研究方法：他建议学生在研究中要“一方面依靠直觉，另一方面要及时吸取新观念来修正直觉”。 
总结来说，杨振宁的物理直觉是一种建立在深厚数学功底之上、以对称性美学为导向、并经过长年深度思考不断修正的科学审美力。 